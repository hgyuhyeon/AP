class Solution {
public:
    long long wonderfulSubstrings(string word) {
        long long ans = 0;
        unordered_map<int, int> pf;
        pf[0] = 1; // 새로 추가된 문자 자기자신
        int bm = 0;
        
        for (char c: word) {
            bm ^= 1 << (c - 'a'); // current prefix pattern
            /*
            1 << (c-'a') 뜻:
            c-'a'한만큼 1을 밀음
            그러면 이제 1, 2, 4, 8, 16, ... 별로 알파벳 위치가 숫자로 변환됨
            그리고 기존 비트마스크와 xor연산:
            만약 비트마스크가 1이었고 새로 들어온게 4면
            100 ^ 1 = 101 ==> 5상태가 되는거임
            */
            ans += pf[bm]; // even, 이전에 있던 prefix들을 더함. 이전에 5를 한 번 만들었다면 더하는거
            /*
            이전에 있던 prefix가 뭐임? ==> acac라고쳐보면
            맨 처음에 a때문에 1상태가 1개 있겠지? (for돌리면 자기자신때문에 ans = 1)
            ac때문에 5상태가 1개 생김
            근데 만약 이전에 5상태를 하나 만들었는데 또 5상태가 된다? 그러면 이제 짝이 맞춰지는거
            그리고 for문을 보면 bm ^ (1 << i)가 있음
            101 ^ 0 = 101(5)
            101 ^ 1 = 100(4)
            101 ^ 10 = 111(7)
            101 ^ 100 = 001(1) <-- a때문에 이전 a가들은 prefix가 하나 있네요? 더하는거임
            순으로 반복하는거임
            그 다음에 a가 옴: 101 ^ 1 = 100 ==> 4상태가 됨
            100 ^ 0 = 100(4)
            100 ^ 1 = 101(5) ==> 1
            100 ^ 10 = 110(6)
            100 ^ 100 = 0 ==> 1
            이전에 존재하는 prefix들을 더해주는거임ㅎㅎ
            그 다음에 c가 옴: 100 ^ 100 ==> 0상태가 됨
            0 ^ 0 = 0 ==> 1
            0 ^ 1 = 1 ==> 1
            0 ^ 10 = 2 
            0 ^ 100 = 4 ==> 1
            0 ^ 1000 = 8
            */
            for (int i = 0; i < 10; i++) ans += pf[bm ^ (1 << i)]; // odd, 해당 위치에 문자가 존재하면 그만큼 더함.
            pf[bm]++; // 새로 만든 prefix를 저장해둠
        }
        return ans;
    }
};